BigDeal <: IndentationSensitive {
    Game = ListOf<Sequence, newline+> end

    Sequence = SequenceStatement+
    SequenceStatement = BlockStatement | SingleLineStatement
    BlockStatement = BlockDefinition | BlockFilter | BlockSequenceReference
    SingleLineStatement = (FieldDefinition | Modification | SequenceReference) newline+

    PureSequence = PureSequenceStatement+
    PureSequenceStatement = BlockStatement | PureSingleLineStatement
    PureSingleLineStatement = (FieldDefinition | SequenceReference) newline+

    BlockOf<X> = newline indent X dedent

    SequenceReference = "take"? "choose"? "next"? "every"? QuantitySpecifier? SequenceLiteral FilterExpression?
    BlockSequenceReference = "take"? "choose"? "next"? "every"? QuantitySpecifier? SequenceLiteral CompoundExpression

    from = "from"
    many = "many"
    unique = "unique"
    keyword = from | many | unique | "of" | "take" | "choose" | "next" | "any" | "all"

	integer = ("0".."9")+
    FractionalNumber = integer "/" integer
    Number = FractionalNumber | integer | many
    index = (integer "th") | "1" "st" | "2" "nd" | "3" "rd"


    text = dquoteText | squoteText
    dquote = "\""
    dquoteText = dquote (~dquote any)* dquote
    squote = "'"
    squoteText = squote (~squote any)* squote

    docContent = (~newline any)*
    docBlock = ("|" docContent (newline | end))+

    identifier = ~keyword ("a".."z" | "A".."Z" | "_")+
    IdentifierPath = identifier ("of" identifier)*

    Atom = Number | IdentifierPath | text

    InlineSequence = NonemptyListOf<Atom, ("," | "or")>
    FillSequence = integer IdentifierPath
    SequenceLiteral = Range | NotExpression | UnaryExpression | BinaryExpression | FillSequence | InlineSequence

    TruthExpression = NotExpression | UnaryExpression | BinaryExpression | CompoundExpression
    NotExpression = "not" (UnaryExpression | BinaryExpression | CompoundExpression | SequenceReference)
    UnaryOperator = "unique"
    UnaryExpression = Atom UnaryOperator
    binaryOperator = "=" -- eq
                   | ">=" -- ge
                   | ">" -- gt
                   | "<=" -- le
                   | "<" -- lt
                   | "!=" -- ne
                   | "in" -- in
                   | "+" -- add
                   | "-" -- sub
                   | "*" -- mul
                   | "/" -- div
    BinaryExpression = Atom binaryOperator SequenceLiteral

    booleanOperator = "any" -- any
                    | "all" -- all

    CompoundExpression = "where" booleanOperator? ":" BlockOf<PureSequence>
    FilterExpression = "where" SequenceLiteral

    Range = Atom "to" Atom
    QuantitySpecifier = (index | Atom) IdentifierPath? from

    FieldDefinition = integer? IdentifierPath ":" SequenceReference ("initially" SequenceReference)?
    BlockDefinition = integer? IdentifierPath ":" SequenceReference? BlockOf<Sequence>
    BlockFilter = FieldDefinition CompoundExpression
    modificationKeyword = "add to" -- add
                        | "prepend to" -- prepend
                        | "change" -- change

    Modification = modificationKeyword IdentifierPath ":" SequenceReference

	newline (a new line) = "\n" "\r"?
    space := " " | "\t"
}
